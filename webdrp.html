<!DOCTYPE html>
<html>

<head>
	<style type="text/css">
		html {
			height: 100%;
		}

		body {
			font-family: sans-serif;
			background-color: #999;
			color: #444;
			margin: 0px;
			height: 100%;
		}

		input[type=number] {
			width: 60px;
		}

		td.tableTitle {
			font-weight: bold;
			width: 200px;
			text-shadow: 0px 1px 1px #ccc;
		}

		td.explanation {
			font-style: italic;
			font-size: small;
			height: 1em;
		}

		#header {
			text-shadow:0px 1px 1px #ccc; 
			background: linear-gradient(to bottom, #ddd 0%,#bbb 100%);
			background: -webkit-linear-gradient(top,  #ddd 0%,#bbb 100%);
			border-bottom: solid #888 1px;
			color: #444;
			font-size: x-large;
			font-weight: bold;
			padding-left: 10px;
			sheight: 30px;
		}

		#container {
			height: 100%;
			width: 100%;
		}

		#mainsvg {
			width: 100%;
			min-width: 100px;
			min-height: 100px;
		}
				
		#contentrow {
			height: 100%;
		}	

		.belowheader {
			background: linear-gradient(to bottom, #eee 0%,#ddd 100%);
			background: -webkit-linear-gradient(top,  #eee,#ddd 100%);
			border-top: solid #ccc 1px;
			padding: 30px;
		}

		#info {
			width: 400px;
			height: 100%;
		}

		svg {
			box-shadow: 1px 1px 6px #333;
			border: solid #888 0px;

		}

		#histSvg {
			height: 300px;
			width: 300px;
			background-color: white;
		}

	</style>

</head>

<body>


<table id=container border=0 cellpadding=10 cellspacing=0>
	<tr>
		<td colspan=2 id="header">WebDRP</td>
	</tr>

	<tr id=contentrow>
		<td class="belowheader" id="mainsvg">
			<svg id="svgDocument" version="1.1" xmlns="http://www.w3.org/2000/svg"
				zoomAndPan="magnify" preserveAspectRatio="xMidYMid meet" style="height: 100%; width: 100%; background-color: #FCFCD9;">
				<g id="controlGroup">
					<rect id="boundRect" stroke="green" fill="rgba(0, 0, 0, 0.05)"></rect>
				</g>

				</g>
			</svg>
		</td>

		<td class="belowheader">

			<table id="info" border=0 cellspacing=0>
				<tr>
					<td class="tableTitle">File:</td><td id="fileName"></td>
				</tr>
				<tr>
					<td class="tableTitle">Size:</td><td id="fileSize"></td>
				</tr>
				<tr>
					<td class="tableTitle">Last modified:</td><td id="fileLastModified">
				</tr>
				<tr>
					<td colspan=2>&nbsp;</td>
				</tr>
				<tr>
					<td class="tableTitle">Top bound:</td><td><input step=1 oninput="boundFromInputs()" type="number" id="topBound"/></td>
				</tr>
				<tr>
					<td class="tableTitle">Bottom bound:</td><td><input oninput="boundFromInputs()" type="number" id="bottomBound"/></td>
				</tr>
				<tr>
					<td class="tableTitle">Left bound:</td><td><input oninput="boundFromInputs()" type="number" id="leftBound"/></td>
				</tr>
				<tr>
					<td class="tableTitle">Right bound:</td><td><input oninput="boundFromInputs()" type="number" id="rightBound"/></td>
				</tr>

				<tr>
					<td colspan=2> &nbsp;</td>
				</tr>
				<tr>
					<td class="tableTitle">Bin width (&#181m):</td><td><input id="binWidth" type="number" min="0.1" max="40" step="0.1" oninput="binsChanged()"></td>
				</tr>
				<tr>
					<td class="tableTitle">Cell count:</td><td id="cellCount"></td>
				</tr>
				<tr>
					<td colspan=2> &nbsp;</td>
				</tr>

				<tr>
					<td colspan=2>	
							<svg id="histSvg" preserveAspectRatio="none">
						</div>
					</td>
				</tr>
				<tr>
					<td colspan=2><input type="file" id="files" name="files"/></td>
				</tr>
				<tr>
					<td colspan=2 class=explanation>(Or drag and drop a file anywhere on this window)</td>
				</tr>

			</table>
		</td>
	</tr>

</table>




<script>
	"use strict";
	var currentFile;
	var fileContents;
	var table;
	var svgCircles;
	var svgns = "http://www.w3.org/2000/svg";
	var circleRadius = 10;
	var svgDocument = document.getElementById('svgDocument');
	var mainGroup = svgDocument.getElementById('mainGroup');
	var boundRect = svgDocument.getElementById('boundRect');
	var minX, maxX, minY, maxY;
	var leftLine, rightLine, topLine, bottomLine;
	var proxCutoff = 200;
	var proxList;
	var binWidth = 10;
	var hist, normHist;
	var dragLines;
	var boundVert, boundHorz;
	var mouseSvgPoint = svgDocument.createSVGPoint();
	var histSvg;

	function readFile(evt)
	{
		document.getElementById("fileName").innerText = currentFile.name;
		document.getElementById("fileLastModified").innerText = currentFile.lastModifiedDate;
		document.getElementById("fileSize").innerText = currentFile.size + " bytes";

		fileContents = evt.target.result;

		var rows = fileContents.match(/[^\r\n]+/g);
		var columnNames = rows[0].match(/[^\s,]+/g)

		var columns = {}
		table = {}
		for (var r in columnNames) {
			columns[r] = new Array(rows.length - 1);
			table[columnNames[r]] = columns[r];
		}

		for (var r=1; r<rows.length; r++) {
			var line = rows[r].match(/[^\s,]+/g);
			for (var c in line) {
				var v = line[c];
				if (!isNaN(v)) v = +v;
				columns[c][r-1] = v;
			}
		}

		plotDots();
	}

	function distance2(x1, y1, x2, y2) {
		var xd = x2 - x1;
		var yd = y2 - y1;
		return xd*xd + yd*yd;
	}

	function pointInBounds(i) {
		if (table.x[i] > boundHorz[1]) return false;
		if (table.x[i] < boundHorz[0]) return false;
		if (table.y[i] > boundVert[1]) return false;
		if (table.y[i] < boundVert[0]) return false;
		return true;
	}

	function binsChanged() {
		binWidth = +document.getElementById('binWidth').value
		calcHist();
	}

	function updateHistSvg() {
		histSvg = document.getElementById('histSvg');
		var barGroup = histSvg.getElementById('barGroup');
		if (barGroup) histSvg.removeChild(barGroup);
		barGroup = document.createElementNS(svgns, 'g');
		barGroup.id = 'barGroup';

		var numBins = normHist.length;
		var maxBin = -1e20;
		for (var i=0; i<numBins; i++) {
			maxBin = Math.max(maxBin, normHist[i]);
			var bar = document.createElementNS(svgns, 'rect');
			bar.setAttribute('x', i);
			bar.setAttribute('y', 0);
			bar.setAttribute('width', 1);
			bar.setAttribute('height', normHist[i]);
			bar.setAttribute('fill', 'orange');
			bar.setAttribute('stroke-width', 0);
			barGroup.appendChild(bar);
		}

		maxBin *= 1.2;
		barGroup.setAttribute("transform", "scale(1, -1)");
		histSvg.appendChild(barGroup);
		histSvg.setAttribute('viewBox', "0 " + (-maxBin) + " " + numBins + " " + maxBin);

		var binSlider = document.getElementById('binWidth');
		binSlider.max = proxCutoff/2;
		binSlider.min = 1;
		binSlider.value = binWidth;
	}

	function calcHist()
	{
		var numPoints = table.x.length;
		var numBins = Math.ceil(proxCutoff / binWidth);
		if (!numBins) numBins = 1;

		hist = new Array(numBins);
		for (var i=0; i<numBins; i++) {
			hist[i] = 0;
		}

		for (var point=0; point<numPoints; point++) {
			if (!pointInBounds(point)) continue;

			var plist = proxList[point];
			for (var rel=0; rel<plist.length; rel++) {
				var bin = (plist[rel] / binWidth) | 0;
				if (bin < numBins) {
					hist[bin]++;
				}
			}
		}

		normHist = new Array(numBins);
		for (var i=0; i<numBins; i++) {
			normHist[i] = hist[i] / ((i+1)*binWidth);
		}

		updateHistSvg();
	}

	function getSvgPoint(evt)
	{
		var crect = svgDocument.getClientRects()[0];
		
		if (true) {
				mouseSvgPoint.x = evt.clientX - crect.left;
				mouseSvgPoint.y = evt.clientY - crect.top;
				mouseSvgPoint = mouseSvgPoint.matrixTransform(mainGroup.getCTM().inverse());
		} else {
			mouseSsvgPoint.x = evt.screenX - crect.left;
			mouseSsvgPoint.y = evt.screenY - crect.top;
			mouseSsvgPoint = mouseSvgPoint.matrixTransform(mainGroup.getScreenCTM().inverse());
		}
		return mouseSvgPoint;
	}

	function svgdown(evt) {
		if (evt.button != 0) return;
		var svgPoint = getSvgPoint(evt);

		var dleft = Math.abs(boundHorz[0] - svgPoint.x)
		var dright = Math.abs(boundHorz[1] - svgPoint.x)
		var dtop = Math.abs(boundVert[0] - svgPoint.y)
		var dbottom = Math.abs(boundVert[1] - svgPoint.y)

		dragLines = {
			horz: dleft < dright ? 0 : 1,
			vert: dtop < dbottom ? 0 : 1
		};

		svgDocument.addEventListener('mousemove', svgmove, true);
		svgmove(evt);
	}

	function svgup(evt) {
		svgDocument.removeEventListener('mousemove', svgmove, true);
		inputsFromBound();
		calcHist();
	}

	function svgmove(evt) {
		evt.preventDefault();

		var svgPoint = getSvgPoint(evt);

		//console.log(svgPoint.x, svgPoint.y)

		if (svgPoint.x < boundHorz[1-dragLines.horz] == dragLines.horz) {
			svgPoint.x = boundHorz[1-dragLines.horz] + (dragLines.horz*2 -1);
		}
		boundHorz[dragLines.horz] = svgPoint.x;	

		if (svgPoint.y < boundVert[1-dragLines.vert] == dragLines.vert) {
			svgPoint.y = boundVert[1-dragLines.vert] + (dragLines.vert*2 -1);
		}
		boundVert[dragLines.vert] = svgPoint.y;
		updateBoundRect();
		calcHist();
	}

	svgDocument.addEventListener('mousedown', svgdown);
	svgDocument.addEventListener('mouseup', svgup);
	svgDocument.addEventListener('mouseout', svgup);

	function makeProxList()
	{
		var numPoints = table.x.length;
		proxList = new Array(numPoints);

		for (var i=0; i<numPoints; i++) {
			proxList[i] = [];
		}

		var proxCutoff2 = 2*proxCutoff;
		proxCutoff2 = proxCutoff2 * proxCutoff2;

		for (var a=0; a<numPoints; a++) {

			var xa = table.x[a];
			var ya = table.y[a];

			for (var b=a+1; b<numPoints; b++) {
				var xb = table.x[b];
				var yb = table.y[b];

				var dist2 = distance2(xa, ya, xb, yb);
				if (dist2 > proxCutoff2) continue;

				var dist = Math.sqrt(dist2);
				proxList[a].push(dist);
				proxList[b].push(dist);
			}
		}
	}

	function handleFileDrop(evt) {
		evt.stopPropagation();
		evt.preventDefault();
		currentFile = evt.dataTransfer.files[0];
		var reader = new FileReader();
		reader.onload = readFile;
		reader.readAsText(currentFile);
	}

	function handleFileSelect(evt) {
		evt.stopPropagation();
		evt.preventDefault();
		currentFile = evt.target.files[0];
		var reader = new FileReader();
		reader.onload = readFile;
		reader.readAsText(currentFile);
	}

	function handleDragOver(evt) {
		evt.stopPropagation();
		evt.preventDefault();
		evt.dataTransfer.dropEffect = 'copy';
	}

	function setCTM(element, matrix) {
        var s = "matrix(" + matrix.a + "," + matrix.b + "," + matrix.c + "," + matrix.d + "," + matrix.e + "," + matrix.f + ")";
        element.setAttribute("transform", s);
	}

	function createLine(x1, y1, x2, y2)
	{
		var line = document.createElementNS(svgns, 'line');
		line.setAttribute("x1", x1);
		line.setAttribute("x2", x2);
		line.setAttribute("y1", y1);
		line.setAttribute("y2", y2);
		line.setAttribute("stroke", "green");
		line.setAttribute("stroke-width", circleRadius);
		return line;
	}

	function boundFromInputs()
	{
		boundHorz[0] = +document.getElementById('leftBound').value;
		boundHorz[1] = +document.getElementById('rightBound').value;
		boundVert[0] = +document.getElementById('topBound').value;
		boundVert[1] = +document.getElementById('bottomBound').value;
		updateBoundRect();
	}

	function inputsFromBound()
	{
		document.getElementById('leftBound').value = boundHorz[0];
		document.getElementById('rightBound').value = boundHorz[1];
		document.getElementById('topBound').value = boundVert[0];
		document.getElementById('bottomBound').value = boundVert[1];
	}

	function updateBoundRect()
	{
		boundHorz[0] = Math.round(boundHorz[0]);
		boundHorz[1] = Math.round(boundHorz[1]);
		boundVert[0] = Math.round(boundVert[0]);
		boundVert[1] = Math.round(boundVert[1]);

		boundRect.x.baseVal.value = boundHorz[0];
		boundRect.y.baseVal.value = boundVert[0];
		boundRect.width.baseVal.value = boundHorz[1] - boundHorz[0];
		boundRect.height.baseVal.value = boundVert[1] - boundVert[0];
	}

	function addCell(i)
	{
		if (true) {
			var shape = document.createElementNS(svgns, "circle");
			shape.setAttribute("cx", table.x[i]);
			shape.setAttribute("cy", table.y[i]);
			shape.setAttribute("r",  circleRadius);
			shape.setAttribute("fill", "black");
			svgCircles[i] = shape;
			mainGroup.appendChild(shape);
		} else {
			var shape = document.createElementNS(svgns, "rect");
			shape.setAttribute("x", table.x[i]-circleRadius);
			shape.setAttribute("y", table.y[i]-circleRadius);
			shape.setAttribute("width",  circleRadius*2);
			shape.setAttribute("height",  circleRadius*2);
			shape.setAttribute("fill", "black");
			shape.setAttribute("stroke", 'rgba(0, 0, 0, 0)');
			svgCircles[i] = shape;
			mainGroup.appendChild(shape);			
		}
	}

	function plotDots(evt)
	{
		if (mainGroup) svgDocument.removeChild(mainGroup);
		mainGroup = document.createElementNS(svgns, 'g');
		svgDocument.appendChild(mainGroup);


		var numPoints = table.x.length;
		document.getElementById("cellCount").innerText = numPoints;
		svgCircles = new Array(numPoints);

		minX = 1e20;
		minY = 1e20;
		maxX = -1e20;
		maxY = -1e20;

		for (var i=0; i<numPoints; i++) {
			addCell(i);

			minX = Math.min(minX, table.x[i]);
			minY = Math.min(minY, table.y[i]);
			maxX = Math.max(maxX, table.x[i]);
			maxY = Math.max(maxY, table.y[i]);
		}

		boundHorz = [minX, maxX];
		boundVert = [minY, maxY];
		boundRect.setAttribute('stroke-width', circleRadius);
		updateBoundRect();

		var margin = (maxY - minY) * 0.05;

		mainGroup.setAttribute("transform", "scale(1, -1)");
		controlGroup.setAttribute("transform", "scale(1, -1)");

		svgDocument.setAttribute('viewBox', (minX-margin) + " " + (-margin-maxY)
			 + " " + (maxX - minX + margin*2) + " " + (maxY - minY + margin*2));

		//svgDocument.setAttribute('viewBox', (minX-margin) + " " + (minY-margin)
		//	 + " " + (maxX - minX + margin*2) + " " + (maxY - minY + margin*2));

		makeProxList();
		inputsFromBound();
		calcHist();
	}

	document.getElementById('files').addEventListener('change', handleFileSelect, false);

	window.addEventListener('dragover', handleDragOver, false);
	window.addEventListener('drop', handleFileDrop, false);


</script>


</body>



</html>

